From 24c39d7bb4bdfbab843c58d0fb6835128d08a9b5 Mon Sep 17 00:00:00 2001
From: SuicidalKids <kfian294ma4@gmail.com>
Date: Tue, 15 Sep 2020 05:06:25 +0100
Subject: [PATCH] Explosion Improvements


diff --git a/src/main/java/me/suicidalkids/ion/IonWorldConfig.java b/src/main/java/me/suicidalkids/ion/IonWorldConfig.java
index 11d7f7d10..284308078 100644
--- a/src/main/java/me/suicidalkids/ion/IonWorldConfig.java
+++ b/src/main/java/me/suicidalkids/ion/IonWorldConfig.java
@@ -64,4 +64,9 @@ public class IonWorldConfig {
         return config.getString("world-settings." + worldName + "." + path, config.getString(path));
     }
 
+    public boolean constantExplosions;
+    private void ConstantExplosions() {
+        constantExplosions = getBoolean("explosions.constant-radius", false);
+    }
+
 }
diff --git a/src/main/java/net/minecraft/server/Explosion.java b/src/main/java/net/minecraft/server/Explosion.java
index f4ccd8d4d..cdbdbb0cc 100644
--- a/src/main/java/net/minecraft/server/Explosion.java
+++ b/src/main/java/net/minecraft/server/Explosion.java
@@ -54,9 +54,15 @@ public class Explosion {
         int i;
         int j;
 
-        Block b = world.getChunkAt((int)posX >> 4, (int)posZ >> 4).getBlockData(new BlockPosition(posX, posY, posZ)).getBlock(); // TacoSpigot - get block of the explosion
+        // IonSpigot start - Block Searching Improvements
+        BlockPosition pos = new BlockPosition(posX, posY, posZ);
+        Chunk chunk = world.getChunkAt(pos.getX() >> 4, pos.getZ() >> 4);
+        Block b = chunk.getBlockData(pos).getBlock(); // TacoSpigot - get block of the explosion
 
         if (!this.world.tacoSpigotConfig.optimizeLiquidExplosions || !b.getMaterial().isLiquid()) { //TacoSpigot - skip calculating what blocks to blow up in water/lava
+            it.unimi.dsi.fastutil.longs.LongSet set = new it.unimi.dsi.fastutil.longs.LongOpenHashSet();
+            searchForBlocks(set, chunk);
+            /*
         for (int k = 0; k < 16; ++k) {
             for (i = 0; i < 16; ++i) {
                 for (j = 0; j < 16; ++j) {
@@ -96,6 +102,11 @@ public class Explosion {
                 }
             }
         }
+            */
+            for (it.unimi.dsi.fastutil.longs.LongIterator iterator = set.iterator(); iterator.hasNext();) {
+                this.blocks.add(BlockPosition.fromLong(iterator.nextLong()));
+            }
+            // IonSpigot end
         }
 
         this.blocks.addAll(hashset);
@@ -121,15 +132,17 @@ public class Explosion {
             Entity entity = (Entity) list.get(l1);
 
             if (!entity.aW()) {
-                double d7 = entity.f(this.posX, this.posY, this.posZ) / (double) f3;
-
-                if (d7 <= 1.0D) {
+                // IonSpigot start - Faster Entity Iteration
+                if (true) {
                     double d8 = entity.locX - this.posX;
                     double d9 = entity.locY + (double) entity.getHeadHeight() - this.posY;
                     double d10 = entity.locZ - this.posZ;
-                    double d11 = (double) MathHelper.sqrt(d8 * d8 + d9 * d9 + d10 * d10);
+                    double distanceSquared = d8 * d8 + d9 * d9 + d10 * d10;
 
-                    if (d11 != 0.0D) {
+                    if (distanceSquared <= 64.0D && distanceSquared != 0.0D) {
+                        double d11 = (double) MathHelper.sqrt(distanceSquared);
+                        double d7 = d11 / f3;
+                        // IonSpigot end
                         d8 /= d11;
                         d9 /= d11;
                         d10 /= d11;
@@ -233,6 +246,8 @@ public class Explosion {
                 Block block = this.world.getType(blockposition).getBlock();
 
                 world.spigotConfig.antiXrayInstance.updateNearbyBlocks(world, blockposition); // Spigot
+                // IonSpigot start - Optimise Explosions
+                /*
                 if (flag) {
                     double d0 = (double) ((float) blockposition.getX() + this.world.random.nextFloat());
                     double d1 = (double) ((float) blockposition.getY() + this.world.random.nextFloat());
@@ -254,6 +269,8 @@ public class Explosion {
                     this.world.addParticle(EnumParticle.EXPLOSION_NORMAL, (d0 + this.posX * 1.0D) / 2.0D, (d1 + this.posY * 1.0D) / 2.0D, (d2 + this.posZ * 1.0D) / 2.0D, d3, d4, d5, new int[0]);
                     this.world.addParticle(EnumParticle.SMOKE_NORMAL, d0, d1, d2, d3, d4, d5, new int[0]);
                 }
+                */
+                // IonSpigot end
 
                 if (block.getMaterial() != Material.AIR) {
                     if (block.a(this)) {
@@ -301,6 +318,82 @@ public class Explosion {
     public List<BlockPosition> getBlocks() {
         return this.blocks;
     }
+    // IonSpigot start - Block Searching Improvements
+    private final static List<double[]> VECTORS = Lists.newArrayListWithCapacity(1352);
+
+    static {
+        for (int k = 0; k < 16; ++k) {
+            for (int i = 0; i < 16; ++i) {
+                for (int j = 0; j < 16; ++j) {
+                    if (k == 0 || k == 15 || i == 0 || i == 15 || j == 0 || j == 15) {
+                        double d0 = (float) k / 15.0F * 2.0F - 1.0F;
+                        double d1 = (float) i / 15.0F * 2.0F - 1.0F;
+                        double d2 = (float) j / 15.0F * 2.0F - 1.0F;
+                        double d3 = Math.sqrt(d0 * d0 + d1 * d1 + d2 * d2);
+
+                        d0 = (d0 / d3) * 0.30000001192092896D;
+                        d1 = (d1 / d3) * 0.30000001192092896D;
+                        d2 = (d2 / d3) * 0.30000001192092896D;
+                        VECTORS.add(new double[] {d0, d1, d2});
+                    }
+                }
+            }
+        }
+    }
+
+    // https://github.com/jellysquid3/lithium-fabric/blob/1.16.x/dev/src/main/java/me/jellysquid/mods/lithium/mixin/world/explosions/ExplosionMixin.java
+    private void searchForBlocks(it.unimi.dsi.fastutil.longs.LongSet set, Chunk chunk) {
+        BlockPosition.MutableBlockPosition blockposition = new BlockPosition.MutableBlockPosition();
+
+        for (double[] vector : VECTORS) {
+            double d0 = vector[0];
+            double d1 = vector[1];
+            double d2 = vector[2];
+
+            float f = this.size * (0.7F + (world.ionConfig.constantExplosions ? 0.7F : this.world.random.nextFloat()) * 0.6F);
+            float resistance = 0;
+
+            double stepX = this.posX;
+            double stepY = this.posY;
+            double stepZ = this.posZ;
+
+            for (; f > 0.0F; f -= 0.22500001F) {
+                int floorX = org.bukkit.util.NumberConversions.floor(stepX);
+                int floorY = org.bukkit.util.NumberConversions.floor(stepY);
+                int floorZ = org.bukkit.util.NumberConversions.floor(stepZ);
+
+                if (blockposition.getX() != floorX || blockposition.getY() != floorY || blockposition.getZ() != floorZ) {
+                    blockposition.setValues(floorX, floorY, floorZ);
+
+                    int chunkX = floorX >> 4;
+                    int chunkZ = floorZ >> 4;
+                    if (chunk == null || !chunk.o() || chunk.locX != chunkX || chunk.locZ != chunkZ) {
+                        chunk = world.getChunkAt(chunkX, chunkZ);
+                    }
+
+                    IBlockData iblockdata = chunk.getBlockData(blockposition);
+                    Block block = iblockdata.getBlock();
+
+                    if (block != Blocks.AIR) {
+                        float blockResistance = block.durability / 5.0f;
+                        resistance = (blockResistance + 0.3F) * 0.3F;
+                        f -= resistance;
+
+                        if (f > 0.0F && (this.source == null || this.source.a(this, this.world, blockposition, iblockdata, f)) && blockposition.getY() < 256 && blockposition.getY() >= 0) { // CraftBukkit - don't wrap explosions
+                            set.add(blockposition.asLong());
+                        }
+                    }
+                } else {
+                    f -= resistance;
+                }
+
+                stepX += d0;
+                stepY += d1;
+                stepZ += d2;
+            }
+        }
+    }
+    // IonSpigot end
 
     // PaperSpigot start - Optimize explosions
     private float getBlockDensity(Vec3D vec3d, AxisAlignedBB aabb) {
@@ -308,9 +401,10 @@ public class Explosion {
             return this.world.a(vec3d, aabb);
         }
 
-        CacheKey key = new CacheKey(this, aabb);
-        Float blockDensity = this.world.explosionDensityCache.get(key);
-        if (blockDensity == null) {
+        // IonSpigot start - Optimise Density Cache
+        int key = createKey(this, aabb);
+        float blockDensity = this.world.explosionDensityCache.get(key);
+        if (blockDensity == -1.0f) {
             blockDensity = this.world.a(vec3d, aabb);
             this.world.explosionDensityCache.put(key, blockDensity);
         }
@@ -318,6 +412,31 @@ public class Explosion {
         return blockDensity;
     }
 
+    static int createKey(Explosion explosion, AxisAlignedBB aabb) {
+        int result;
+        long temp;
+        result = explosion.world.hashCode();
+        temp = Double.doubleToLongBits(explosion.posX);
+        result = 31 * result + (int) (temp ^ (temp >>> 32));
+        temp = Double.doubleToLongBits(explosion.posY);
+        result = 31 * result + (int) (temp ^ (temp >>> 32));
+        temp = Double.doubleToLongBits(explosion.posZ);
+        result = 31 * result + (int) (temp ^ (temp >>> 32));
+        temp = Double.doubleToLongBits(aabb.a);
+        result = 31 * result + (int) (temp ^ (temp >>> 32));
+        temp = Double.doubleToLongBits(aabb.b);
+        result = 31 * result + (int) (temp ^ (temp >>> 32));
+        temp = Double.doubleToLongBits(aabb.c);
+        result = 31 * result + (int) (temp ^ (temp >>> 32));
+        temp = Double.doubleToLongBits(aabb.d);
+        result = 31 * result + (int) (temp ^ (temp >>> 32));
+        temp = Double.doubleToLongBits(aabb.e);
+        result = 31 * result + (int) (temp ^ (temp >>> 32));
+        temp = Double.doubleToLongBits(aabb.f);
+        result = 31 * result + (int) (temp ^ (temp >>> 32));
+        return result;
+    }
+    /* // IonSpigot - comment this out
     static class CacheKey {
         private final World world;
         private final double posX, posY, posZ;
@@ -382,5 +501,7 @@ public class Explosion {
             return result;
         }
     }
+    */
+    // IonSpigot end
     // PaperSpigot end
 }
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 72a8105fe..435c93040 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -137,7 +137,12 @@ public abstract class World implements IBlockAccess {
     private org.spigotmc.TickLimiter tileLimiter;
     private int tileTickPosition;
     public ExecutorService lightingExecutor = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setNameFormat("PaperSpigot - Lighting Thread").build()); // PaperSpigot - Asynchronous lighting updates
-    public final Map<Explosion.CacheKey, Float> explosionDensityCache = new HashMap<Explosion.CacheKey, Float>(); // PaperSpigot - Optimize explosions
+    // IonSpigot start - Optimise Density Cache
+    public final it.unimi.dsi.fastutil.ints.Int2FloatMap explosionDensityCache = new it.unimi.dsi.fastutil.ints.Int2FloatOpenHashMap(); // IonSpigot - Use faster collection here // PaperSpigot - Optimize explosions
+    {
+        explosionDensityCache.defaultReturnValue(-1.0f);
+    }
+    // IonSpigot end
 
     public static long chunkToKey(int x, int z)
     {
-- 
2.20.1.windows.1

